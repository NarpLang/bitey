#!/usr/bin/env ruby
require 'fileutils'
require 'time'

BITEY_DIR = '/usr/bitey'
LOCK_FILE = File.join(BITEY_DIR, 'lock')
SOFTWARE_DIR = File.join(BITEY_DIR, 'software')
PROJECT_DIR = File.join(BITEY_DIR, 'project')
PATHS_FILE = File.join(PROJECT_DIR, 'bitey_paths')
RC_FILE = File.join(PROJECT_DIR, 'biteyrc')
LOCAL_PATH = File.expand_path('~/.local/bitey')

unless Dir.exist?(LOCAL_PATH)
  FileUtils.mkdir_p(LOCAL_PATH)
end

def locked?
  File.exist?(LOCK_FILE)
end

def lock
  File.write(LOCK_FILE, Time.now.strftime("%H:%M %d.%m.%Y"))
end

def unlock
  FileUtils.rm_f(LOCK_FILE)
end

def locksmith
  if locked?
    timestamp_str = File.read(LOCK_FILE).strip

    begin
      lock_time = Time.strptime(timestamp_str, "%H:%M %d.%m.%Y")
      age = Time.now - lock_time

      if age > LOCK_TIMEOUT
        puts "‚ö†Ô∏è  Hey, so the lock may be corrupted... It's been ten minutes..."
        print "Remove it? [Y/n] "
        response = $stdin.gets.strip.downcase
        if response == "y" || response.empty?
          unlock
          lock
          return
        else
          puts "‚ùå Operation cancelled due to lock."
          exit 1
        end
      else
        puts "üîí Bitey is locked. Run 'sudo bitey unlock' to remove the lock."
        exit 1
      end

    rescue ArgumentError
      puts "‚ö†Ô∏è  Lock file is corrupted. Removing it."
      unlock
      lock
    end
  else
    lock
  end
end

def run_cmd(command)
  success = system(command)
  unless success
    puts "‚ùå Command failed: #{command}"
    unlock
    exit 1
  end
end

def git_with_progress(*args, label: nil)
  latest_progress = ""
  max_line_length = 0

  # Insert '--progress' before the destination path
  git_args = args.dup
  git_args.insert(-2, '--progress') if git_args.size >= 2

  IO.popen(['git', *git_args], err: [:child, :out]) do |io|
    io.each do |line|
      line = line.strip

      if line.include?("\r")
        latest_progress = line.split("\r").last.strip
      else
        latest_progress = line
      end

      output = label ? "#{label} - #{latest_progress}" : latest_progress
      max_line_length = [max_line_length, output.length].max

      print "\r#{output.ljust(max_line_length)}"
      $stdout.flush
    end
  end
  puts ""
  return latest_progress
end

def update_remotes
  puts "ü¶¥ Updating Remotes..."
  sleep(0.3)
  puts "---"

  Dir["/usr/bitey/software/remote-*/remote.sh"].each do |remote_file|
    remote_dir = File.dirname(remote_file)
    remote_name = File.basename(remote_dir).sub(/^remote-/, '')

    # Extract vars
    env = {}
    IO.popen(["bash", "-c", "source #{remote_file} && env"], err: [:child, :out]) do |io|
      io.each_line do |line|
        key, val = line.chomp.split("=", 2)
        env[key] = val
      end
    end

    icon = env["REMOTE_ICON"] || "üì¶"
    name = env["REMOTE_NAME"] || "Unknown Remote"
    print "#{icon} #{name} (#{remote_name}) ... "

    if File.directory?("#{remote_dir}/.git")
      run_cmd("git -C #{remote_dir} pull --quiet")
      puts "‚úÖ"
    elsif File.executable?("#{remote_dir}/updater.sh")
      run_cmd("sudo #{remote_dir}/updater.sh")
    else
      puts "‚ö†Ô∏è  No updater found"
    end
  end

  puts "---"
end

def install(remote_name, *args)
  noconfirm = args.delete("--noconfirm")
  noupdate  = args.delete("--noupdate")
  is_dep    = args.delete("--dep")
  noconfirm ||= args.delete("-y")

  packages = args

  locksmith
  FileUtils.mkdir_p(SOFTWARE_DIR) unless Dir.exist?(SOFTWARE_DIR)
  update_remotes unless noupdate

  unless noconfirm
    puts "‚ÑπÔ∏è You are about to make changes in the system.\n\nüì¶ Installing:"
    packages.each { |pkg| puts "  - #{pkg}" }

    print "\n‚ùì Are you sure? [Y/n] "
    confirm = $stdin.gets.chomp
    if confirm.downcase != "y" && confirm != ""
      puts "‚ùå Cancelled."
      unlock
      return
    end
    puts ""
  end

  puts "ü¶¥ Making changes to the system..."
  installed = []
  packages.each_with_index do |package, idx|
    remote_addon = File.join(BITEY_DIR, 'software', "remote-#{remote_name}")
    remote_script = File.join(remote_addon, 'remote.sh')
    install_path = File.join(SOFTWARE_DIR, package)

    unless File.exist?(remote_script)
      puts "\n‚ùå Bitzy doesn't know where to go... (Remote '#{remote_name}' not found or invalid.)"
      unlock
      exit 1
    end

    remote = File.readlines(remote_script).find { |l| l.strip.start_with?("REMOTE=") }&.split('=', 2)&.last&.gsub('"', '')&.strip

    if remote.nil? || remote.empty?
      puts "\n‚ùå Bitzy doesn't know where to go, nothing on the information paper... (REMOTE not set.)"
      unlock
      exit 1
    end

    if Dir.exist?(install_path)
      if is_dep
         puts "‚úÖ #{package} is already installed (dependency)."
      else
         puts "‚ö†Ô∏è Bitzy found out that #{package} is already installed. Skipping..."
      end
      next
    end

    label = "üì¶ [#{idx + 1}/#{packages.size}] Installing #{package}..."
    git_with_progress("clone", "#{remote}/#{package}", "#{install_path}", label: label)
    $stdout.flush

    Dir.chdir(install_path) do
      if File.exist?("project/depends.txt")
        deps = File.readlines("project/depends.txt").map(&:strip).reject(&:empty?)
        deps.each do |dep|
          puts "\nüì¶ Installing dependency #{dep}..."
          unlock
          run_cmd("sudo bitey install #{dep} --noconfirm --noupdate --dep")
          lock
        end
      end

      run_cmd("bash project/install.sh")
      Dir.glob("bin/*").each { |f| FileUtils.chmod("+x", f) }

      File.open(PATHS_FILE, 'a') { |f| f.puts install_path }
      File.open(RC_FILE, 'a') { |f| f.puts File.join(install_path, 'bin') }
      installed << package
    end
  end

  puts "‚úÖ Bitzy installed #{installed.join(', ')}." unless installed.empty?
  unlock
end


def remove(*packages)
  locksmith

  puts "‚ÑπÔ∏è You are about to make changes in the system.\n\nüóëÔ∏è Removing:"
  packages.each { |pkg| puts "  - #{pkg}" }

  print "\n‚ùì Are you sure? [Y/n] "
  confirm = $stdin.gets.chomp
  if confirm.downcase != "y" && confirm != ""
    puts "‚ùå Cancelled."
    unlock
    return
  end

  packages.each_with_index do |software, idx|
    install_path = File.join(SOFTWARE_DIR, software)

    unless Dir.exist?(install_path)
      puts "‚ùå Bitzy thinks #{software} is not installed."
      next
    end

    Dir.chdir(install_path) do
      if File.exist?('project/remove.sh')
        puts "üîß Bitzy is running remove script for #{software}..."
        run_cmd("sudo bash project/remove.sh")
      else
        puts "‚ö†Ô∏è Bitzy didn't find a remove script, continuing with raw removal."
      end
    end

    print "üóëÔ∏è [#{idx+1}/#{packages.size}] Removing #{software} ... "
    puts ""
    FileUtils.rm_rf(install_path)

    # Clean bitey_paths and biteyrc
    [PATHS_FILE, RC_FILE].each do |file|
      next unless File.exist?(file)
      lines = File.readlines(file).reject { |line| line.strip == install_path || line.strip == File.join(install_path, 'bin') }
      File.write(file, lines.join)
    end

    puts "‚úÖ Bitzy removed #{software}."
  end

  unlock
end

def update
  locksmith
  update_remotes

  bitey_paths = File.exist?(PATHS_FILE) ? File.readlines(PATHS_FILE, chomp: true) : []
  biteyrc = File.exist?(RC_FILE) ? File.readlines(RC_FILE, chomp: true) : []

  total = bitey_paths.size
  width = 90  # Adjust terminal width for progress bar alignment

  bitey_paths.each_with_index do |path, idx|
    next unless Dir.exist?(path)

    label = "üîÑ [#{idx+1}/#{total}] Updating #{File.basename(path)}..."

    Dir.chdir(path) do
      puts "#(label)"
      run_cmd("git reset --quiet --hard HEAD")
      run_cmd("git pull --quiet")
      run_cmd("chmod +x bin/*") if Dir.exist?('bin')

      if File.exist?('project/update.sh')
        puts "üîß Running update script for #{File.basename(path)}..."
        run_cmd("bash project/update.sh")
      end
    end
  end

  File.write(PATHS_FILE, bitey_paths.join("\n") + "\n")
  File.write(RC_FILE, biteyrc.join("\n") + "\n")
  unlock
end


def print_help
  puts <<~HELP
    üê∂ Hi, it's Bitzy! I wrote down some commands you need to know down here!
    üí° Bitey Help
    ‚û°Ô∏è Usage: bitey [OPTIONS]

    üì¶ Packages:
        install <remote> <package> - Install a package.
        remove <package> - Remove a package.
        list - List installed packages.
        update - Update all packages.
        info <package> - See the package information.
        search [-u] <remote> <search_term> - Search for a package.

    üîê Lock:
        lock - Lock Bitey.
        unlock - Unlock Bitey.

    üíø Installation:
        doctor - Analyze your installation of Bitey.
        repair - Repair your installation of Bitey.
        --version - Check the version of your Bitey Installation.

    ‚ùì Help:
        --help - See the help message.

    üêæ Tip: Use the Bitey Shell (run `bitey shell`) to manage everything faster!
  HELP
end

def info(package)
  if package.nil? || package.strip.empty?
    puts "‚ùå Please provide a package name."
    exit 1
  end

  package_dir = File.join(SOFTWARE_DIR, package)
  conf_file = File.join(package_dir, 'pak.conf')

  unless File.exist?(conf_file)
    puts "‚ùå Package '#{package}' is not installed."
    exit 1
  end

  # Load variables from pak.conf
  conf = {}
  File.readlines(conf_file).each do |line|
    next unless line.include?('=')
    key, value = line.strip.split('=', 2)
    conf[key] = value.gsub(/^['"]|['"]$/, '') # remove quotes
  end

  puts "üì¶ Package Info: #{package}"
  puts "Name: #{conf['PACKAGE_NAME'] || package}"
  puts "Version: #{conf['PACKAGE_VERSION'] || 'Unknown'}"
  puts "Maintainer: #{conf['PACKAGE_MAINTAINER'] || 'Unknown'}"
  puts "Description: #{conf['PACKAGE_DESCRIPTION'] || 'No description'}"
  puts "Location: #{package_dir}"

  # Load additional info from biteydb if it exists
  biteydb_path = "/usr/bitey/software/biteydb/data/#{package}.txt"
  if File.exist?(biteydb_path)
    puts
    puts File.read(biteydb_path)
  end
end

def doctor
  puts "ü©∫ Bitey Doctor Report"
  puts

  # Lock status
  if File.exist?(File.join(BITEY_DIR, "lock"))
    puts "üîê Lock status:        ‚ùå Locked"
  else
    puts "üîê Lock status:        ‚úÖ Unlocked"
  end

  # Root directory
  if Dir.exist?(BITEY_DIR)
    puts "üìÇ BITEY directory:    ‚úÖ #{BITEY_DIR}"
  else
    puts "üìÇ BITEY directory:    ‚ùå Not found"
  end

  # Installed packages
  if Dir.exist?(SOFTWARE_DIR)
    pkgs = Dir.children(SOFTWARE_DIR).select { |e| File.directory?(File.join(SOFTWARE_DIR, e)) }
    puts "üì¶ Installed packages: ‚úÖ #{pkgs.count} packages found"
  else
    puts "üì¶ Installed packages: ‚ùå None"
  end

  # Broken packages
  broken_pkgs = []
  Dir.glob("#{SOFTWARE_DIR}/*").each do |pkg_dir|
    next unless File.directory?(pkg_dir)
    unless File.exist?(File.join(pkg_dir, "project", "install.sh"))
      broken_pkgs << File.basename(pkg_dir)
      puts "üß© Broken package:     ‚ùå #{File.basename(pkg_dir)} (no install.sh)"
    end
  end
  puts "üß© Broken packages:    ‚úÖ None" if broken_pkgs.empty?

  # Missing pak.conf
  missing_conf = []
  Dir.glob("#{SOFTWARE_DIR}/*").each do |pkg_dir|
    next unless File.directory?(pkg_dir)
    unless File.exist?(File.join(pkg_dir, "pak.conf"))
      missing_conf << File.basename(pkg_dir)
      puts "üìë Missing pak.conf:   ‚ùå #{File.basename(pkg_dir)}"
    end
  end
  puts "üìë Missing pak.conf:   ‚úÖ All present" if missing_conf.empty?

  # Disk usage
  usage = `du -sh "#{BITEY_DIR}" 2>/dev/null`.split("\t").first
  puts "üìÅ Disk usage:         üíæ #{usage || "Unknown"} used by Bitey"

  # Permission check
  if Process.uid == 0
    puts "üîß Data access:        ‚úÖ Safe (running as root)"
  elsif File.writable?(BITEY_DIR)
    puts "üîß Data access:        ‚ö†Ô∏è Unsafe (use with caution)"
  else
    puts "üîß Data access:        ‚ùå None (no write access)"
  end

  # Remotes
  remotes_dir = File.join(BITEY_DIR, "addons")
  if Dir.exist?(remotes_dir)
    remotes = Dir.glob("#{remotes_dir}/remote-*").select { |d| File.directory?(d) }
    if remotes.any?
      puts "üåê Remotes configured: ‚úÖ #{remotes.count} remotes"
    else
      puts "üåê Remotes configured: ‚ùå None found"
    end
  else
    puts "üåê Remotes configured: ‚ùå None found"
  end

  puts
  puts "‚úÖ All checks complete."
end

def repair
  puts "üîß Bitey Repair Utility"
  puts

  repaired = 0
  Dir.glob("#{SOFTWARE_DIR}/*").each do |pkg_dir|
    next unless File.directory?(pkg_dir)
    pkg = File.basename(pkg_dir)
    install_script = File.join(pkg_dir, "project", "install.sh")
    pak_conf = File.join(pkg_dir, "pak.conf")

    if !File.exist?(install_script) || !File.exist?(pak_conf)
      puts "‚ö†Ô∏è  #{pkg} is broken."

      print "   ‚Üí Do you want to remove this package? [y/N]: "
      choice = $stdin.gets.strip.downcase
      if choice == "y"
        system("sudo", "rm", "-rf", pkg_dir)
        puts "   ‚úÖ Removed #{pkg}"
        repaired += 1
      else
        puts "   ‚ùå Skipped #{pkg}"
      end
    end
  end

  if repaired > 0
    puts
    puts "‚úÖ Repair complete. #{repaired} package(s) removed."
  else
    puts "‚úÖ No broken packages found."
  end
end

def search(*args)
  require 'optparse'

  options = { update: false }
  parser = OptionParser.new do |opts|
    opts.on('-u', '--update', 'Update remotes before searching') do
      options[:update] = true
    end
  end

  # Parse the arguments, leaving remaining ones
  remaining = parser.parse(args)

  if remaining.length != 2
    puts "üîß Usage: search [-u] <remote> <search_term>"
    return
  end

  remote = remaining[0]
  search_term = remaining[1]
  package_list_path = "/usr/bitey/software/remote-#{remote}/package.list"

  if options[:update]
    update_remotes
  end

  unless File.exist?(package_list_path)
    puts "‚ÑπÔ∏è Package list not found for remote '#{remote}'"
    return
  end

  puts "üîç Searching for '#{search_term}' in remote '#{remote}'..."
  File.foreach(package_list_path) do |line|
    puts "- #{line}" if line.downcase.include?(search_term.downcase)
  end
end

def find(remote)
  if remote.nil? || remote.strip.empty?
    puts "‚ùå Please provide a remote name."
    exit 1
  end
  package_list_path = "/usr/bitey/software/remote-#{remote}/package.list"

  unless File.exist?(package_list_path)
    puts "‚ÑπÔ∏è Package list not found for remote '#{remote}'"
    return
  end

  puts "üì¶ Listing all packages in remote '#{remote}':"
  File.foreach(package_list_path) do |line|
    puts "- #{line.chomp}"
  end
end

# Main execution starts here
if ARGV.empty?
  puts "üê∂ Run 'bitey --help' for usage."
  exit 0
end

command = ARGV.shift

case command
when 'install'
  remote_name = ARGV.shift
  install(remote_name, *ARGV)
when 'remove'
  remove(*ARGV)
when 'update'
  update
when 'list'
  list_packages
when '--help', 'help'
  print_help
when 'info'
  info(ARGV[0])
when 'lock'
  lock
when 'unlock'
  unlock
when 'doctor'
  doctor
when 'repair'
  repair
when 'search'
  search(*ARGV)
when 'find'
  find(ARGV[0])
else
  puts "‚ùì Unknown command: #{command}"
end
