#!/usr/bin/env ruby
require 'fileutils'

BITEY_DIR = '/usr/bitey'
LOCK_FILE = File.join(BITEY_DIR, 'lock')
SOFTWARE_DIR = File.join(BITEY_DIR, 'software')
PROJECT_DIR = File.join(BITEY_DIR, 'project')
PATHS_FILE = File.join(PROJECT_DIR, 'bitey_paths')
RC_FILE = File.join(PROJECT_DIR, 'biteyrc')
LOCAL_PATH = File.expand_path('~/.local/bitey')

unless Dir.exist?(LOCAL_PATH)
  FileUtils.mkdir_p(LOCAL_PATH)
end

def locked?
  File.exist?(LOCK_FILE)
end

def lock
  FileUtils.touch(LOCK_FILE)
end

def unlock
  FileUtils.rm_f(LOCK_FILE)
end

def run_cmd(command)
  success = system(command)
  unless success
    puts "âŒ Command failed: #{command}"
    unlock
    exit 1
  end
end

def update_remotes
  puts "ğŸ¦´ Updating Remotes..."
  sleep(0.3)
  puts "---"

  Dir["/usr/bitey/software/remote-*/remote.sh"].each do |remote_file|
    remote_dir = File.dirname(remote_file)
    remote_name = File.basename(remote_dir).sub(/^remote-/, '')

    # Extract vars from shell script
    env = {}
    IO.popen(["bash", "-c", "source #{remote_file} && env"], err: [:child, :out]) do |io|
      io.each_line do |line|
        key, val = line.chomp.split("=", 2)
        env[key] = val
      end
    end

    icon = env["REMOTE_ICON"] || "ğŸ“¦"
    name = env["REMOTE_NAME"] || "Unknown Remote"

    puts "#{icon} #{name} (#{remote_name}) ..."

    if File.directory?("#{remote_dir}/.git")
      run_cmd("sudo git -C #{remote_dir} pull")
    elsif File.executable?("#{remote_dir}/updater.sh")
      run_cmd("sudo #{remote_dir}/updater.sh")
    else
      puts "âš ï¸  No updater found for #{remote_name}"
    end
  end

  puts "---"
end

def install(remote_name, *packages)
  if locked?
    puts "ğŸ”’ Bitey is locked. Run 'sudo bitey unlock' to remove the lock."
    exit 1
  end

  lock
  FileUtils.mkdir_p(SOFTWARE_DIR) unless Dir.exist?(SOFTWARE_DIR)

  update_remotes

  puts "â„¹ï¸ You are about to make changes in the system.\n\nğŸ“¦ Installing:"
  packages.each { |pkg| puts "  - #{pkg}" }

  print "\nâ“ Are you sure? [Y/n] "
  confirm = $stdin.gets.chomp
  if confirm.downcase != "y" && confirm != ""
    puts "âŒ Cancelled."
    unlock
    return
  end

  puts "\nğŸ¦´ Making changes to the system..."
  packages.each_with_index do |package, idx|
    remote_addon = File.join(BITEY_DIR, 'software', "remote-#{remote_name}")
    remote_script = File.join(remote_addon, 'remote.sh')
    install_path = File.join(SOFTWARE_DIR, package)

    unless File.exist?(remote_script)
      puts "âŒ Bitzy doesn't know where to go... (Remote '#{remote_name}' not found or invalid.)"
      unlock
      exit 1
    end

    remote = File.readlines(remote_script).find { |l| l.strip.start_with?("REMOTE=") }&.split('=', 2)&.last&.gsub('"', '')&.strip

    if remote.nil? || remote.empty?
      puts "âŒ Bitzy doesn't know where to go, nothing on the information paper... (REMOTE not set.)"
      unlock
      exit 1
    end

    if Dir.exist?(install_path)
      puts "âš ï¸ Bitzy found out that #{package} is already installed. Skipping..."
      next
    end

    print "ğŸ“¦ [#{idx+1}/#{packages.size}] Installing #{package} ... "
    puts ""
    run_cmd("git clone #{remote}/#{package} #{install_path}")
    puts "done."

    Dir.chdir(install_path) do
      if File.exist?("project/depends.txt")
        deps = File.readlines("project/depends.txt").map(&:strip).reject(&:empty?)
        deps.each do |dep|
          puts "ğŸ“¦ Installing dependency #{dep}..."
          run_cmd("sudo bitey install #{dep}")
        end
      end

      run_cmd("bash project/install.sh")
      Dir.glob("bin/*").each { |f| FileUtils.chmod("+x", f) }

      File.open(PATHS_FILE, 'a') { |f| f.puts install_path }
      File.open(RC_FILE, 'a') { |f| f.puts File.join(install_path, 'bin') }
    end

    puts "âœ… Bitzy installed #{package}."
  end

  unlock
end


def remove(*packages)
  if locked?
    puts "ğŸ”’ Bitey is locked. Run 'sudo bitey unlock' to remove the lock."
    exit 1
  end

  lock

  puts "â„¹ï¸ You are about to make changes in the system.\n\nğŸ—‘ï¸ Removing:"
  packages.each { |pkg| puts "  - #{pkg}" }

  print "\nâ“ Are you sure? [Y/n] "
  confirm = $stdin.gets.chomp
  if confirm.downcase != "y" && confirm != ""
    puts "âŒ Cancelled."
    unlock
    return
  end

  packages.each_with_index do |software, idx|
    install_path = File.join(SOFTWARE_DIR, software)

    unless Dir.exist?(install_path)
      puts "âŒ Bitzy thinks #{software} is not installed."
      next
    end

    Dir.chdir(install_path) do
      if File.exist?('project/remove.sh')
        puts "ğŸ”§ Bitzy is running remove script for #{software}..."
        run_cmd("sudo bash project/remove.sh")
      else
        puts "âš ï¸ Bitzy didn't find a remove script, continuing with raw removal."
      end
    end

    print "ğŸ—‘ï¸ [#{idx+1}/#{packages.size}] Removing #{software} ... "
    puts ""
    FileUtils.rm_rf(install_path)

    # Clean bitey_paths and biteyrc
    [PATHS_FILE, RC_FILE].each do |file|
      next unless File.exist?(file)
      lines = File.readlines(file).reject { |line| line.strip == install_path || line.strip == File.join(install_path, 'bin') }
      File.write(file, lines.join)
    end

    puts "âœ… Bitzy removed #{software}."
  end

  unlock
end

def update
  if locked?
    puts "ğŸ”’ Bitey is locked. Run 'sudo bitey unlock' to remove the lock."
    exit 1
  end

  lock

  update_remotes

  bitey_paths = File.exist?(PATHS_FILE) ? File.readlines(PATHS_FILE, chomp: true) : []
  biteyrc = File.exist?(RC_FILE) ? File.readlines(RC_FILE, chomp: true) : []

  bitey_paths.each do |path|
    next unless Dir.exist?(path)

    Dir.chdir(path) do
      puts "ğŸ”„ Bitzy is updating path #{path}..."
      run_cmd("sudo git reset --hard HEAD")
      run_cmd("sudo git pull")
      run_cmd("sudo chmod +x bin/*") if Dir.exist?('bin')

      if File.exist?('project/update.sh')
        puts "ğŸ”§ Bitzy is running update script..."
        run_cmd("sudo bash project/update.sh")
      end
    end
  end

  # Rewrite files (to preserve updated structure)
  File.write(PATHS_FILE, bitey_paths.join("\n") + "\n")
  File.write(RC_FILE, biteyrc.join("\n") + "\n")

  unlock
end

def list_packages
  unless Dir.exist?(SOFTWARE_DIR)
    puts "âŒ No packages installed."
    exit 1
  end

  puts "ğŸ“¦ Installed Bitey packages:"
  Dir.entries(SOFTWARE_DIR).each do |entry|
    next if ['.', '..'].include?(entry)
    path = File.join(SOFTWARE_DIR, entry)
    puts " - #{entry}" if File.directory?(path)
  end
end

def print_help
  puts <<~HELP
    ğŸ¶ Hi, it's Bitzy! I wrote down some commands you need to know down here!
    ğŸ’¡ Bitey Help
    â¡ï¸ Usage: bitey [OPTIONS]

    ğŸ“¦ Packages:
        install <remote> <package> - Install a package.
        remove <package> - Remove a package.
        list - List installed packages.
        update - Update all packages.
        info <package> - See the package information.
        search [-u] <remote> <search_term> - Search for a package.

    ğŸš Shell:
        shell - Open a Bitey Shell session.
        exit - Quit the Shell.
        reload - Reload the Shell.
        clear - Clear the Shell.
        history - Read your history.
        help - See the help message.
        version - Check the version of your Bitey installation.

    ğŸ” Lock:
        lock - Lock Bitey.
        unlock - Unlock Bitey.

    ğŸ’¿ Installation:
        doctor - Analyze your installation of Bitey.
        repair - Repair your installation of Bitey.
        --version - Check the version of your Bitey Installation.

    â“ Help:
        --help - See the help message.

    ğŸ¾ Tip: Use the Bitey Shell (run `bitey shell`) to manage everything faster!
  HELP
end

def info(package)
  if package.nil? || package.strip.empty?
    puts "âŒ Please provide a package name."
    exit 1
  end

  package_dir = File.join(SOFTWARE_DIR, package)
  conf_file = File.join(package_dir, 'pak.conf')

  unless File.exist?(conf_file)
    puts "âŒ Package '#{package}' is not installed."
    exit 1
  end

  # Load variables from pak.conf
  conf = {}
  File.readlines(conf_file).each do |line|
    next unless line.include?('=')
    key, value = line.strip.split('=', 2)
    conf[key] = value.gsub(/^['"]|['"]$/, '') # remove quotes
  end

  puts "ğŸ“¦ Package Info: #{package}"
  puts "Name: #{conf['PACKAGE_NAME'] || package}"
  puts "Version: #{conf['PACKAGE_VERSION'] || 'Unknown'}"
  puts "Maintainer: #{conf['PACKAGE_MAINTAINER'] || 'Unknown'}"
  puts "Description: #{conf['PACKAGE_DESCRIPTION'] || 'No description'}"
  puts "Location: #{package_dir}"

  # Load additional info from biteydb if it exists
  biteydb_path = "/usr/bitey/software/biteydb/data/#{package}.txt"
  if File.exist?(biteydb_path)
    puts
    puts File.read(biteydb_path)
  end
end

def doctor
  puts "ğŸ©º Bitey Doctor Report"
  puts

  # Lock status
  if File.exist?(File.join(BITEY_DIR, "lock"))
    puts "ğŸ” Lock status:        âŒ Locked"
  else
    puts "ğŸ” Lock status:        âœ… Unlocked"
  end

  # Root directory
  if Dir.exist?(BITEY_DIR)
    puts "ğŸ“‚ BITEY directory:    âœ… #{BITEY_DIR}"
  else
    puts "ğŸ“‚ BITEY directory:    âŒ Not found"
  end

  # Installed packages
  if Dir.exist?(SOFTWARE_DIR)
    pkgs = Dir.children(SOFTWARE_DIR).select { |e| File.directory?(File.join(SOFTWARE_DIR, e)) }
    puts "ğŸ“¦ Installed packages: âœ… #{pkgs.count} packages found"
  else
    puts "ğŸ“¦ Installed packages: âŒ None"
  end

  # Broken packages
  broken_pkgs = []
  Dir.glob("#{SOFTWARE_DIR}/*").each do |pkg_dir|
    next unless File.directory?(pkg_dir)
    unless File.exist?(File.join(pkg_dir, "project", "install.sh"))
      broken_pkgs << File.basename(pkg_dir)
      puts "ğŸ§© Broken package:     âŒ #{File.basename(pkg_dir)} (no install.sh)"
    end
  end
  puts "ğŸ§© Broken packages:    âœ… None" if broken_pkgs.empty?

  # Missing pak.conf
  missing_conf = []
  Dir.glob("#{SOFTWARE_DIR}/*").each do |pkg_dir|
    next unless File.directory?(pkg_dir)
    unless File.exist?(File.join(pkg_dir, "pak.conf"))
      missing_conf << File.basename(pkg_dir)
      puts "ğŸ“‘ Missing pak.conf:   âŒ #{File.basename(pkg_dir)}"
    end
  end
  puts "ğŸ“‘ Missing pak.conf:   âœ… All present" if missing_conf.empty?

  # Disk usage
  usage = `du -sh "#{BITEY_DIR}" 2>/dev/null`.split("\t").first
  puts "ğŸ“ Disk usage:         ğŸ’¾ #{usage || "Unknown"} used by Bitey"

  # Permission check
  if Process.uid == 0
    puts "ğŸ”§ Data access:        âœ… Safe (running as root)"
  elsif File.writable?(BITEY_DIR)
    puts "ğŸ”§ Data access:        âš ï¸ Unsafe (use with caution)"
  else
    puts "ğŸ”§ Data access:        âŒ None (no write access)"
  end

  # Remotes
  remotes_dir = File.join(BITEY_DIR, "addons")
  if Dir.exist?(remotes_dir)
    remotes = Dir.glob("#{remotes_dir}/remote-*").select { |d| File.directory?(d) }
    if remotes.any?
      puts "ğŸŒ Remotes configured: âœ… #{remotes.count} remotes"
    else
      puts "ğŸŒ Remotes configured: âŒ None found"
    end
  else
    puts "ğŸŒ Remotes configured: âŒ None found"
  end

  puts
  puts "âœ… All checks complete."
end

def repair
  puts "ğŸ”§ Bitey Repair Utility"
  puts

  repaired = 0
  Dir.glob("#{SOFTWARE_DIR}/*").each do |pkg_dir|
    next unless File.directory?(pkg_dir)
    pkg = File.basename(pkg_dir)
    install_script = File.join(pkg_dir, "project", "install.sh")
    pak_conf = File.join(pkg_dir, "pak.conf")

    if !File.exist?(install_script) || !File.exist?(pak_conf)
      puts "âš ï¸  #{pkg} is broken."

      print "   â†’ Do you want to remove this package? [y/N]: "
      choice = $stdin.gets.strip.downcase
      if choice == "y"
        system("sudo", "rm", "-rf", pkg_dir)
        puts "   âœ… Removed #{pkg}"
        repaired += 1
      else
        puts "   âŒ Skipped #{pkg}"
      end
    end
  end

  if repaired > 0
    puts
    puts "âœ… Repair complete. #{repaired} package(s) removed."
  else
    puts "âœ… No broken packages found."
  end
end

def shell
  puts "ğŸ¦´ Welcome to Bitey Shell!"
  puts "Type 'help' for available commands. Type 'exit' to quit."

  loop do
    print "bitey> "
    input = $stdin.gets
    break if input.nil?

    input.strip!
    next if input.empty?

    case input
    when 'exit'
      puts "ğŸ‘‹ Exiting shell."
      break
    when 'clear'
      system("clear")
    else
      # Fake ARGV for internal dispatch
      original_argv = ARGV.dup
      ARGV.replace(input.split)
      command = ARGV.shift

      case command
      when 'install'
        install(ARGV.shift, *ARGV)
      when 'remove'
        remove(*ARGV[1..])
      when 'update'
        update
      when 'list'
        list_packages
      when 'info'
        info(ARGV[0])
      when 'lock'
        lock
      when 'unlock'
        unlock
      when 'doctor'
        doctor
      when 'repair'
        repair
      when 'help', '--help'
        print_help
      else
        puts "â“ Unknown command: #{command}"
      end

      ARGV.replace(original_argv)
    end
  end
end

def search(*args)
  require 'optparse'

  options = { update: false }
  parser = OptionParser.new do |opts|
    opts.on('-u', '--update', 'Update remotes before searching') do
      options[:update] = true
    end
  end

  # Parse the arguments, leaving remaining ones
  remaining = parser.parse(args)

  if remaining.length != 2
    puts "ğŸ”§ Usage: search [-u] <remote> <search_term>"
    return
  end

  remote = remaining[0]
  search_term = remaining[1]
  package_list_path = "/usr/bitey/software/remote-#{remote}/package.list"

  if options[:update]
    update_remotes
  end

  unless File.exist?(package_list_path)
    puts "â„¹ï¸ Package list not found for remote '#{remote}'"
    return
  end

  puts "ğŸ” Searching for '#{search_term}' in remote '#{remote}'..."
  File.foreach(package_list_path) do |line|
    puts line if line.downcase.include?(search_term.downcase)
  end
end

# Main execution starts here
if ARGV.empty?
  puts "ğŸ¶ Run 'bitey --help' for usage."
  exit 0
end

command = ARGV.shift

case command
when 'install'
  remote_name = ARGV.shift
  install(remote_name, *ARGV)
when 'remove'
  remove(*ARGV)
when 'update'
  update
when 'list'
  list_packages
when '--help', 'help'
  print_help
when 'info'
  info(ARGV[0])
when 'lock'
  lock
when 'unlock'
  unlock
when 'doctor'
  doctor
when 'repair'
  repair
when 'shell'
  shell
when 'search'
  search(*ARGV)
else
  puts "â“ Unknown command: #{command}"
end
