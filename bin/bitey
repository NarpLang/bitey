#!/usr/bin/env ruby

require 'fileutils'

VERSION = '1.8'
BITEY = '/usr/bitey'

# Helpers
def locked?
  File.exist?("#{BITEY}/lock")
end

def ensure_unlocked
  if locked?
    puts "ğŸ”’ Bitey is locked. Run 'sudo bitey unlock' to remove the lock."
    exit 1
  end
end

def run_cmd(cmd)
  puts "=> #{cmd}"
  system(cmd) || abort("âŒ Command failed: #{cmd}")
end

# Commands
case ARGV[0]
when 'install'
  ensure_unlocked
  system('sudo bitey lock')

  Dir.mkdir("#{BITEY}/software") unless Dir.exist?("#{BITEY}/software")

  remote_name = ARGV[1]
  packages = ARGV[2..]
  remote_addon = "#{BITEY}/addons/remote-#{remote_name}"
  remote_script = File.join(remote_addon, 'remote.sh')

  unless File.file?(remote_script)
    abort("âŒ Bitzy doesn't know where to go... (Remote '#{remote_name}' not found or invalid.)")
  end

  remote = nil
  eval(File.read(remote_script))

  unless defined?(REMOTE)
    abort("âŒ Bitzy doesn't know where to go... REMOTE not set in #{remote_script}.")
  end

  packages.each do |pkg|
    install_path = "#{BITEY}/software/#{pkg}"

    if Dir.exist?(install_path)
      puts "âš ï¸ Bitzy found out that #{pkg} is already installed. Skipping..."
      next
    end

    puts "ğŸ“¦ Bitzy is installing #{pkg}..."
    run_cmd("sudo git clone #{REMOTE}/#{pkg} #{install_path}")

    unless File.exist?("#{install_path}/project/paths.txt")
      puts "âŒ Installation invalid."
      FileUtils.rm_rf(install_path)
      next
    end

    depends_file = "#{install_path}/project/depends.txt"
    if File.exist?(depends_file)
      eval(File.read(depends_file))
      system('sudo bitey unlock')
      DEPENDS&.each do |dep|
        puts "ğŸ“¦ Installing dependency #{dep}..."
        run_cmd("sudo bitey install #{dep}")
      end
      system('sudo bitey lock')
    end

    run_cmd("sudo bash #{install_path}/project/install.sh")
    run_cmd("sudo chmod +x #{install_path}/bin/*")

    File.open("#{BITEY}/project/bitey_paths", 'a') { |f| f.puts install_path }
    File.open("#{BITEY}/project/biteyrc", 'a') { |f| f.puts "#{install_path}/bin" }
    puts "âœ… Bitzy installed #{pkg}."
  end

  system('sudo bitey unlock')

when 'remove'
  ensure_unlocked
  system('sudo bitey lock')
  ARGV[1..].each do |pkg|
    install_path = "#{BITEY}/software/#{pkg}"
    unless Dir.exist?(install_path)
      puts "âŒ Bitzy thinks #{pkg} is not installed."
      next
    end

    Dir.chdir(install_path) do
      if File.exist?('project/remove.sh')
        puts "ğŸ”§ Bitzy is running remove script for #{pkg}..."
        run_cmd('sudo bash project/remove.sh')
      end
    end

    puts "ğŸ—‘ï¸ Bitzy is removing #{pkg}..."
    FileUtils.rm_rf(install_path)

    ["#{BITEY}/project/bitey_paths", "#{BITEY}/project/biteyrc"].each do |file|
      next unless File.exist?(file)
      content = File.readlines(file).reject { |line| line.strip == install_path || line.strip == "#{install_path}/bin" }
      File.write(file, content.join)
    end

    puts "âœ… Bitzy removed #{pkg}."
  end
  system('sudo bitey unlock')

when 'update'
  ensure_unlocked
  system('sudo bitey lock')

  bitey_paths = File.readlines("#{BITEY}/project/bitey_paths").map(&:strip)
  bitey_paths.each do |path|
    next unless Dir.exist?(path)
    Dir.chdir(path) do
      puts "ğŸ”„ Bitzy is updating path #{path}..."
      run_cmd('sudo git reset --hard HEAD')
      run_cmd('sudo git pull')
      run_cmd('sudo chmod +x bin/*')
      run_cmd('sudo bash project/update.sh') if File.exist?('project/update.sh')
    end
  end

  File.write("#{BITEY}/project/bitey_paths", bitey_paths.join("\n") + "\n")
  File.write("#{BITEY}/project/biteyrc", bitey_paths.map { |p| "#{p}/bin" }.join("\n") + "\n")

  system('sudo bitey unlock')

when 'list'
  dir = "#{BITEY}/software"
  if !Dir.exist?(dir) || Dir.empty?(dir)
    puts "âŒ No packages installed."
  else
    puts "ğŸ“¦ Installed Bitey packages:"
    Dir.each_child(dir) { |entry| puts " - #{entry}" if File.directory?(File.join(dir, entry)) }
  end

when '--help', nil
  puts <<~HELP
    ğŸ¶ Hi, it's Bitzy! Here's what I can do:
    ğŸ“¦ install <remote> <package>...  Install packages from a remote.
    ğŸ“¦ remove <package>...            Remove installed packages.
    ğŸ“¦ list                           List all installed packages.
    ğŸ“¦ update                         Update all installed packages.
    ğŸ“¦ info <package>                Show info about a package.
    ğŸ” lock | unlock                 Lock or unlock Bitey.
    ğŸ©º doctor                         Run installation diagnostics.
    ğŸš shell-related: shell, exit, clear, history, reload, help, version
    â“ --help                        Show this help message.
    ğŸ“„ --version                    Show version.
  HELP

when '--version'
  puts "ğŸ« Bitey #{VERSION}"

when 'info'
  pkg = ARGV[1]
  pkg_dir = "#{BITEY}/software/#{pkg}"
  unless pkg && File.exist?("#{pkg_dir}/pak.conf")
    abort("âŒ Package '#{pkg}' is not installed.")
  end
  conf = File.read("#{pkg_dir}/pak.conf")
  eval(conf)
  puts "ğŸ“¦ Package Info: #{pkg}"
  puts "Name: #{defined?(PACKAGE_NAME) ? PACKAGE_NAME : pkg}"
  puts "Version: #{defined?(PACKAGE_VERSION) ? PACKAGE_VERSION : 'Unknown'}"
  puts "Maintainer: #{defined?(PACKAGE_MAINTAINER) ? PACKAGE_MAINTAINER : 'Unknown'}"
  puts "Description: #{defined?(PACKAGE_DESCRIPTION) ? PACKAGE_DESCRIPTION : 'No description'}"
  puts "Location: #{pkg_dir}"

when 'lock'
  FileUtils.touch("#{BITEY}/lock") unless locked?

when 'unlock'
  FileUtils.rm_f("#{BITEY}/lock") if locked?

when 'doctor'
  puts "ğŸ©º Bitey Doctor Report"
  puts ""
  puts "ğŸ” Lock status:        #{locked? ? 'âŒ Locked' : 'âœ… Unlocked'}"
  puts "ğŸ“‚ BITEY directory:    #{Dir.exist?(BITEY) ? "âœ… #{BITEY}" : 'âŒ Not found'}"

  software_dir = "#{BITEY}/software"
  if Dir.exist?(software_dir)
    pkgs = Dir.children(software_dir).select { |d| File.directory?(File.join(software_dir, d)) }
    puts "ğŸ“¦ Installed packages: âœ… #{pkgs.size} packages found"
    broken = pkgs.select { |p| !File.exist?("#{software_dir}/#{p}/project/install.sh") }
    broken.each { |b| puts "ğŸ§© Broken package:     âŒ #{b} (no install.sh)" }
    puts "ğŸ§© Broken packages:    âœ… None" if broken.empty?
  else
    puts "ğŸ“¦ Installed packages: âŒ None"
  end

else
  puts "ğŸ¶ Unknown command: #{ARGV[0]}. Run 'bitey --help' for usage."
end
